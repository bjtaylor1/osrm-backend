# nginx configuration for OSRM geographic routing
# Routes requests to appropriate OSRM backend based on coordinates

# Upstream servers for each geographic slice
upstream osrm_north_america {
    server 127.0.0.1:5000 max_fails=3 fail_timeout=30s;
    keepalive 32;
}

upstream osrm_south_america {
    server 127.0.0.1:5001 max_fails=3 fail_timeout=30s;
    keepalive 32;
}

upstream osrm_europe {
    server 127.0.0.1:5002 max_fails=3 fail_timeout=30s;
    keepalive 32;
}

upstream osrm_africa {
    server 127.0.0.1:5003 max_fails=3 fail_timeout=30s;
    keepalive 32;
}

upstream osrm_asia {
    server 127.0.0.1:5004 max_fails=3 fail_timeout=30s;
    keepalive 32;
}

upstream osrm_oceania {
    server 127.0.0.1:5005 max_fails=3 fail_timeout=30s;
    keepalive 32;
}

# Lua script for coordinate-based routing (requires lua-nginx-module)
# Alternative: use JavaScript (nginx njs module) or external routing service

server {
    listen 80 default_server;
    server_name _;

    access_log /var/log/nginx/osrm_access.log combined;
    error_log /var/log/nginx/osrm_error.log warn;

    # Increase timeouts for long route calculations
    proxy_connect_timeout 60s;
    proxy_send_timeout 60s;
    proxy_read_timeout 60s;

    # Health check endpoint
    location = /health {
        access_log off;
        return 200 "healthy\n";
        add_header Content-Type text/plain;
    }

    # Status page for monitoring
    location = /status {
        access_log off;
        return 200 "All OSRM instances running\n";
        add_header Content-Type text/plain;
    }

    # Direct slice access (for debugging and testing)
    location ~ ^/slice/north_america/(.*)$ {
        proxy_pass http://osrm_north_america/$1$is_args$args;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }

    location ~ ^/slice/south_america/(.*)$ {
        proxy_pass http://osrm_south_america/$1$is_args$args;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
    }

    location ~ ^/slice/europe/(.*)$ {
        proxy_pass http://osrm_europe/$1$is_args$args;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
    }

    location ~ ^/slice/africa/(.*)$ {
        proxy_pass http://osrm_africa/$1$is_args$args;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
    }

    location ~ ^/slice/asia/(.*)$ {
        proxy_pass http://osrm_asia/$1$is_args$args;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
    }

    location ~ ^/slice/oceania/(.*)$ {
        proxy_pass http://osrm_oceania/$1$is_args$args;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
    }

    # Main routing logic
    # Parse coordinates from request and route to appropriate backend
    location ~ ^/(route|match|nearest|table|trip|tile)/v1/ {
        # Extract coordinates from URL
        # Format: /route/v1/bicycle/lon1,lat1;lon2,lat2
        # We'll use the first coordinate to determine which slice
        
        set $backend "";
        set $coords "";
        
        # Default to Europe (most central)
        set $backend "osrm_europe";
        
        # Extract first coordinate pair
        if ($request_uri ~ "/v1/[^/]+/([^;?]+)") {
            set $coords $1;
        }
        
        # Parse first longitude (simplified - production would use Lua/njs)
        # North America: -170 to -50
        if ($coords ~ "^-1[0-6][0-9],") {
            set $backend "osrm_north_america";
        }
        if ($coords ~ "^-[5-9][0-9],") {
            set $backend "osrm_north_america";
        }
        
        # South America: -85 to -30
        if ($coords ~ "^-[3-8][0-9],") {
            set $test_lat $coords;
            # Check if latitude is negative (southern hemisphere)
            if ($test_lat ~ ",-[0-9]") {
                set $backend "osrm_south_america";
            }
        }
        
        # Europe/North Africa: -25 to 60
        if ($coords ~ "^-?[0-5][0-9]?,") {
            set $backend "osrm_europe";
        }
        
        # Africa: -20 to 55
        if ($coords ~ "^[0-5][0-9]?,") {
            # Check if latitude is negative
            if ($coords ~ ",-[0-9]") {
                set $backend "osrm_africa";
            }
        }
        
        # Asia: 60 to 180
        if ($coords ~ "^[6-9][0-9],") {
            set $backend "osrm_asia";
        }
        if ($coords ~ "^1[0-7][0-9],") {
            set $backend "osrm_asia";
        }
        
        # Oceania: 110 to 180 (Southern hemisphere)
        if ($coords ~ "^1[1-7][0-9],") {
            if ($coords ~ ",-[0-9]") {
                set $backend "osrm_oceania";
            }
        }
        
        # Proxy to determined backend
        proxy_pass http://$backend;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-OSRM-Backend $backend;
        
        add_header X-OSRM-Slice $backend always;
    }

    # Fallback for other OSRM endpoints
    location / {
        proxy_pass http://osrm_europe;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}

# Optional: HTTPS configuration
# server {
#     listen 443 ssl http2;
#     server_name your-domain.com;
#     
#     ssl_certificate /etc/ssl/certs/osrm.crt;
#     ssl_certificate_key /etc/ssl/private/osrm.key;
#     
#     # Include same location blocks as above
# }